* Progress of Gameplay
# mention layers of developement?
For the interim demo we made the decision to focus on gameplay mechanics. As a lot of work went into building 
our own engine from scratch, we left the visuals at a basic level for the time being. 
In the following we elaborate on our progress so far. \\

In terms of gameplay we have been able finish up layer 1 and 2 mentioned in our proposal. 
This means that the player is able to move the cube on the field by using the W,A,S,D buttons.
As intended the cube slides on slippery tiles without changing its orientation until it hits an obstacle or a 
wall. The main task then is to navigate the cube through the level in order to get to the finish tile.
Inputs can further be buffered while the cube is moving. This makes the cube instantly move into
that direction when it arrives at a location.\\
# screenshot of lvl1
#+caption: Sample Level 1 including the movable cube, the red finish tile and brown obstacle tiles
#+name: Fig:Lvl1
#+attr_latex: :options [htbp] :width 0.4\textwidth
#+begin_figure 
#+begin_center
#+name: Fig:Level1
 [[../images/lvl1.png]] 
#+end_center
#+end_figure
When moving onto a dry tile, the cube will flip into that direction. In order to finish 
these levels the cube would have to reach the finish tile in one of three specific orientations.
For that we color-coded the sides as red, green and blue with one color represented on two opposites 
sides of the cube. Thanks to the angle of the camera the player can always observe all different sides of the cube
and plan ahead.
Furthermore depending on the level the finish tile can be slippery or dry adding flexibility to level
designs.
# screenshot of lvl2
#+caption: Sample Level 2 including the green dry tiles and red finish with green circle that requires the green side of the cube to be on top/bottom
#+name: Fig:Lvl2
#+attr_latex: :options [htbp] :width 0.4\textwidth
#+begin_figure 
#+begin_center
#+name: Fig:Level2
 [[../images/lvl2.png]] 
#+end_center
#+end_figure
* Engine Work
As the development of our own game engine makes up the major part of our project
we will first go over our current progress on the specific components and how
they relate to the layers of development. The engine was programmed in C++ while
using the Vulkan Graphics API for the render pipeline.
** Vulkan Initialization
The Vulkan Graphics API is a fairly young graphics API developed by the Khronos
Group that was developed with the intent of leaving a higher amount of control
to the developer. In turn this low level access means that the initialization
and creation of the render pipeline was extensive.
*** Validation Layers
*** Loading the Vulkan  Library
*** Creating a Vulkan Instance
*** Physical and logical devices
*** Device Queue
** Creation of the render pipeline
Just as the Initialization is more elaborate compared to other high level
Graphics API's, Vulkans render pipeline is also compromised of many elements
that we will further explain in this chapter.
*** Window Extension
*** Presentation surface
*** Creating a swapchain
*** Buffers
*** Images
*** Command Buffers
*** Descriptor Sets
*** Sampler
*** Render Pass
*** Framebuffer
*** Shader
*** Normal mapped geometry
*** Model Matrix
** Engine Structure
Obviously the graphics pipeline is only part of the engine. Every game engine
needs to handle the games resources such as the scenes, game objects, , . During
the development a high importance was given to make the engine work as efficient
as possible aswell as a. In the following paragraphs we will explain which
systems are already in place and how they were implemented.
*** Resource Allocation
*** Bucket Allocater
Meshes, textures, scenes all need to live in memory somewhere. But instead of
heap allocating them all separately, we wrote an allocator to keep them
together. The bucket allocator is basically a dynamic array of buckets, which
are fixed-sized arrays. On startup the bucket allocator allocates itself a chunk
of memory to hold the initial amout of buckets. When later all buckets are full,
it allocates more buckets. No entries need to be copied, the only thing that
needs to be updated is the dynamic array that holds the pointers to the buckets.
Since no elements will ever move, it is safe to store and use pointers to them
everywhere. When elemets are freed, they are added to a free list, where they
will be reused on the next allocation. The bucket allocator also provides
functionality to iterate over all allocated elements. Bucket allocators are used
for:

 - Textrues
 - Meshes
 - Scenes
 - Materials
 - Scheduler (storing active animations and scheduled actions)

** Scheduler
Actions and Animations are scheduled as lambda functions that determine when the
animation should run, what should be animated and what type of function, either
a lambda function or a closer.
*** Scheduler Structure
*** Lambda functions & Closures
*** High resolution clock
High resolution clock mit =QueryPerformanceCounter= um einen performance counter
von der cpu auszulesen-> teil vom scheduler um zu wissen wann die ausgefÃ¼hrt
werden
*** Animation Lock
sobald animation beginnt setzt er ein optional Lock, pro object: animation Lock.
Falls Lock fÃ¼r Object existiert werden keine weiteren Animations ausgefÃ¼hrt fÃ¼r
dieses Objekt.
** Animations
Due to the structure of the scheduler any variable can be animated using the
animation system. Right now there are 4 types of animations implemented: Ease
in, Ease out, Ease in and out ,and Lerp. Example Fov animation when finishing a
level. All animations happen logically right after another but the scheduler
schedules the animations one after another.
*** Ease in
*** Ease out
*** Ease in and out
*** Lerp
*** Movement
*** Example Animation: Flip Cube
** Game Logic
For the Game Objects that make up our scene we have right now implemented the
following categories 'start pos', 'finish' and 'obstacles' and 'slippery tiles'.
All tiles have a specific corresponding movement (sequence of animations)
connected to them.
*** Slippery tiles
Slippery tiles are the fundamental part of the game. When the cube reaches a
slippery tile it will slide until it reaches an obstacle. The sliding animation
is computed using the Lerp function on the position values of the transform
matrix.
*** Dry tiles
When moving on or onto a dry tile the cube flips over the bottom edge that
corresponds to the direction that was input by the user. The flip movement is
made up of 3 distinct movements:
*** Finish tiles
*** Obstacles
*** Level Loading
A early Layer 3 goal for our project was the ability to load levels from a text
file so we can streamline the level creation process that will be a major part
for the alpha release milestone. The object and structure coordinates in the
text file are grouped into categories and designated with 'begin category' and
'end category' which the map loader will then use to create a scene objects.
Additionally the finish tiles have a extra keyword that determines whether they
are slippery or dry and which color condition of the cube has to be fulfilled to
finish the level. The rest of the tiles are automatically set to slippery.
* Game Demo
# tbh keine Ahnung was da rein soll
* Challenges & Design Revisions
# Minh: Vielleicht zum Thema Input Buffering oder Level Loading?
When implementing the gameplay mechanics we encountered minor issues which were resolved
rather quickly. The win condition as well as the different behaviors of the cube when reaching
specific tiles in itself were not our biggest challenges either. \\
Our main concerns were all in regards to the implementation of the engine.

* Meta Info                                                        :noexport:
#+options: html-postamble:nil toc:nil title:nil
#+macro: insert_game_name_here qubi
#+macro: insert_team_name_here FünfKopf

#+author: Felix Brendel, Jonas Helms, Van Minh Pham
#+title: Interim Demo: {{{insert_game_name_here}}}

#+latex_header: \input{latex.tex}

