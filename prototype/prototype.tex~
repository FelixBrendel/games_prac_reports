% Created 2020-11-29 So 22:07
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\input{latex.tex}
\author{Felix Brendel, Jonas Helms, Van Minh Pham}
\date{\today}
\title{Prototype: qubi}
\hypersetup{
 pdfauthor={Felix Brendel, Jonas Helms, Van Minh Pham},
 pdftitle={Prototype: qubi},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.50 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\section{Prototype Description}
\label{sec:org7292f64}
For the phyiscal prototype of the second milestone we decided to use paper,
domino tiles and wooden cubes. We first used a six sided Pokemon-themed die as
the player-controlled cube to test in our sample level Figure. The dominoes were
used as the map barrier while the wooden cubes performed the task of the
collideable objects in the level.

For each of the three game mechanics that qubi has --
sliding, flipping, unfolding -- we implemented a physical test level, that
showcases that mechanic. The layout of the first sample level, featuring
sliding, together with its phsical implementation can be seen in \ref{org0ad0501}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4\textwidth]{../images/level1.png}
\includegraphics[width=0.4\textwidth]{../images/Paper_prototype_img/sample_lvl_1.jpeg}  
\end{center}
\caption{\label{org0ad0501}Layout and physical prototype of the first sample level}
\end{figure}

In order to test out dry tiles a second prototype was created which was supposed
to resemble the second sample level. For the representation of these dry tiles
we used colored strips of paper as can be observed in the following. The
different colors do not carry a specific meaning, they were just used to make
the it clear where each tile starts and ends.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4\textwidth]{../images/level2.png}
\includegraphics[width=0.4\textwidth]{../images/Paper_prototype_img/sample_lvl_2.jpg}
\end{center}
\caption{\label{org63d8adb}Layout and physical prototype of sample level 2}
\end{figure}

Furthermore we created a foldable prototype from paper to test the third major
game mechanic, the unfolding of the cube, in a rudimentary test level. Due to
the physical limitations the cube can obviously not freely unfold and only use
the pre-determined cuts.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.3\textwidth]{../images/unfoldSample.png} 
\includegraphics[width=0.4\textwidth]{../images/Paper_prototype_img/sample_lvl_3.jpeg}
\end{center}
\caption{\label{org145f195}Layout and physical prototype of the rudimentary unfolding test level}
\end{figure}

\section{Observations \& Revisions}
\label{sec:org55c86b7}
During the creation of the physical prototype we realized several attributes,
problems and design possibilities that we did not think about before. In the
following sections we will highlight the most significant new perspectives that
we gained in the prototyping process.

\subsection{Transition from slippery to dry tile}
\label{sec:orgaffc680}
Testing the prototype for the second sample level (\ref{org63d8adb}) brought
up the question of how the cube should behave when moving from a slippery
surface onto a dry one and vice versa. Both possibilities of a sliding
transition and a flipping motion seemed equally plausible as both options
influence the task of designing levels roughly the same. That being said, we
made the decision to have the cube always flip by 90 degrees when
transitioning between slippery and dry tiles. This seemed like the more
consistent and "realistic" option to us.

\subsection{Number of differentiable cube surfaces}
\label{sec:org2e341aa}
With the concept of dry tiles, on which the cube would move by flipping by 90
degrees, we introduced new finish tiles. In order to complete such levels the
cube would have to land on these finish tiles in a specific orientation.

An further observation that was made in the second prototype (\ref{org63d8adb})
was that this initial concept would cause levels to become too complex if all
six surfaces of the cube mattered. As a result we made the change reduce the
number of all differentiable surfaces down to three. We feel it reduces the
complexity down to a more reasonable level. As it would be too hard to plan
ahead the moves to land on one specific side.

\subsection{State of finish tiles}
\label{sec:org6f6ca9e}
When testing our prototype one of the first things that we realized was that
there is a significant difference whether the finish tile is slippery or dry. We
see this aspect as a new angle in the level design as we can create levels that
seem simple on the first glance but are more complex as the direct route would
let the cube slide beyond the finish tile. This type of level design is
especially suited for the first tier where the only mechanic available are the
sliding tiles.

\subsection{Unfold direction of the cube}
\label{sec:orge62a4b8}
The player is supposed unfold the cube in order to reach a tile they would
otherwise slide over or not reach in the first place. In the initial attempt of
the sample level (\ref{org145f195}) in which we tried the unfolding
mechanic, we made the mistake of having the remainders of the partially unfolded
cube stick the starting tile instead of moving forward. Having made this mistake
it made us further consider whether the player should be able to unfold the cube
anywhere as long as they are standing still or the cube can only be unfolded on
dry tiles.

If the player could unfold the cube anywhere, even when standing on a slippery
tile, the player could just "walk" everywhere, and it would be impossible to
design interesting levels.

\subsection{Game Speed \& Animation Locking}
\label{sec:org796b8c6}
While watching our footage we noticed that the animation/game speed was slower
than we want the game to run in. The movement of the cube has to feel responsive
while at the same time consider the animation locking that we want to implement
due to gameplay reasons. We believe that one effective way to balance these
aspects is to implement input buffering, which allows the user to input a new
command while the cube is still locked in its current animation. This new
command will then be executed as soon as the last animation has finished.
\end{document}
