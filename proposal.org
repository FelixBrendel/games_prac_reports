#+options:  html-postamble:nil toc:nil title:nil
#+macro: insert_game_name_here qubie or quboi
#+macro: insert_team_name_here FünfKopf

#+author: Felix Brendel, Jonas Helms, Van Minh Pham
#+title: Game Idea Proposal: {{{insert_game_name_here}}}

#+latex_header: \usepackage[margin=1in]{geometry}
#+latex_header: \usepackage{titling}
#+latex_header: \renewcommand{\familydefault}{\sfdefault}

#+begin_export latex
\begin{titlepage}
\begin{center}
\vspace*{2 cm}
\huge
\textbf{\thetitle}

\vspace{1cm}
\Large
Team \textit{FünfKopf}:

\vspace{0.2cm}
Felix Brendel \\ Jonas Helms \\ Van Minh Pham

\vspace{2cm}
\large
November 2020

\end{center}
\tableofcontents
\end{titlepage}
\clearpage
#+end_export

* Game Description

We as the team {{{insert_team_name_here}}} believe that great games build on
simple concepts. A perfect example for such a game is [[https://en.wikipedia.org/wiki/Portal_(video_game)][Portal]] (Valve, 2007). The
games magazine GameStar even ranked it number one in the list of the 250 best pc
games of all time, which they published as the special edition 01/2020.

** Game design of Portal

Protal builds on the concept of portals that connect two positions in the game
world. When the players moves through one, they will come out of the other one.
Using this, the game is devided into levels, each with a starting point and a
target the players have to reach.

Just having this concept -- teleporting to another position -- alone however, is
not enough to create an intersting game. Starting from the simple concept one
can begin to shape the game mechanics by exploring different ideas. In the case
of Portal they might have looked like this:

 1. What if the players could place the portals thmeselves?
    - Give the players a portal gun and let them shoot the walls to place
      portals on them
 2. What if there are some surfaces, the players cannot place portals on?
    - If players can place portals everywhere, it might be hard to create
      challenging levels, so also use surfaces, where no portalas can be placed
      on
 3. What if some levels require the players to transport objects in the levels
    to solve them?
    - Let players pick up and carry one object at a time. This also harmonizes
      with the the Portal mechanic, as players can carry objects through the
      portal, adding depth to the game design.
 4. What if there are some barriers, that when moved through, destroy the
    carried object?
    - Letting the players carry the objects freely through the level might make
      the levels too easy, so use barriers where the players cannot carry
      objects through; they will have to find another way

It is interesting to note, that idea 2 and 4 seem to be direct responses to the
ideas 1 and 3.

#+attr_latex: :width 0.4\textwidth
#+caption: The layered design of the game portal
[[./images/design_portal.png]]

** Game design of {{{insert_game_name_here}}}

Seeing this we also wanted to design our game in a similar fashion. Our game
concept follows the given theme /wet and slippery/: *The players should slide
around on a slippery floor*[fn:slippery]. This is our main mechanic.


We decided with this mechanic the most fitting game would be a puzzle game where
the player controls a simple object. This is where we had to make some
descisions.

[fn:slippery] Of course the word slippery is a bit vague. We thought about what
    it means to us if something is "sippery" or "wet". We came up with these
    simple definitions: Slippery is an attribut of a surface which implies that
    the surface friction is low and the attribute slippery can only be observed
    when another object is touching and sliding on it. "Wet" on the other hand
    is to us the sensation you feel when you touched a liquid. Usually it is
    connected to a reduced surface friction of wet objects.

***  2D vs 3D

It was clear, that a 3D game would fit better to the setting of this practical
course. However we also really liked the idea of 3D puzzle games

*** What kind of object should the player control?

 - A sphere      :: There are some games that successfully use spheres as the
   players' characters, however it seemed that a sphere would not feel like
   slipping on the ground, it would rather be a rolling motion.
 - A cube        :: Could be a good option
 - A tetrahedron :: Could be a good option

Of course, as with Portal, we need to ask ourselves explorative questions to
experiment with additional mechanics.

*** What if not the whole ground is slippery?

If there are some sections on the ground that are not slippery, we could make
the cube flip on it's side instead. We can make this an additional game
mechanic, where the sides of the cubes are different in some way -- maybe they
are colored differently, or have different shapes on them. Then we could let the
finish tile only activate when the cube reaches it *and* is oriented correctly.

*** What if the object could unfold?

The two objects we considred, cubes and tetrahedrons can unfold, onto a two
dimensional plane. For a cube the unfoldings would lie on a regular square grid,
while the unfoldings of a tetrahedron lie on a regular triangle tiling. For this
game we first consider the cube as a base shape, as it allows for

We wanted to add only one more mechanic to our game -- one more ability that the
player has, that will let us design more deep and interesting puzzles. A sample
unfolding can be seen in Figure [[fig:unfolding_blender]].

#+name: fig:unfolding_blender
#+caption: The unfolding of the cube, following the player's inputs of =up, right, right, up, right=
[[./images/unfolding_blender2.png]]


Note also, that inherently from the fundamental geometric princaples, there is a
limited amout of valid unfoldings. An illustration of all possible unfoldings
can be seen in Figure [[fig:unfoldings_scheme]]. This is the kind of complexity in a
puzzle game we really want to highlight. Everybody can imagine a cube flipping
over and think about which side will be facing upwards or downwards, but using
this complexity -- which is really accessible to everybody -- we can then design
levels that require the player to plan ahead their movement and flips and
unfolds throughout the level.

#+name: fig:unfoldings_scheme
#+caption: All possible
#+attr_latex: :width 0.4\textwidth
[[./images/unfolding_schemes.png]]

*** Bring it all together
TODO(Felix) explain the details one more time

- {{{insert_game_name_here}}} is a tile-based puzzle game
- in each level the player moves a cube from start tile to finish tile
- multiple floor-types:
  - slippery floor:
    - cube cannot change moving direction after button input until obstacle is hit
    - cube does not change the orientation of the cube
  - floors with grip:
    - on one button press cube moves only once
    - cube turns with each movement
- add mechanics every few levels -> steady learning curve:
  - cube is colored differently on every side
  - cube needs to be in a specific orientation on the finish tile
  - cube can be folded open:
    - bridge slippery tiles
    - multiple finish tiles one which all cube sides have to be in the end
  - player has to set tile types themselves
- so far no story or context, just fun puzzling for the sake of fun puzzling
  -> more freedom for ideas, not bound to setting or story
  -> bigger emphasis on simplicity


** Setting of {{{insert_game_name_here}}}

TODO(FELIX): this

** Sample level

TODO(FELIX): this

* Technical Achievement
# detail core technical item (1+)
As part of the development of {{{insert_game_name_here}}} our group will develop
our own Game Engine. The game engine will use the Vulkan Graphics API to
implement a rendering pipeline. Vulkan is a new API developed by the Khronos
Group (maintainer of OpenGL) with a focus on overhead reduction and was released
in 2016. Using Vulkan has several advantages such as the ability to run on all
operating systems and devices, explicit control over memory management and a
decreased CPU workload due to reduced driver overhead and batching. Furthermore
Vulkan pre-compiles shaders into its own binary format called SPIR-V instead of
compiling the shaders at runtime. This allows the use of a larger number of
different shaders per scene and reduces application load times. The decision to
use the Vulkan API was made due the general design goal of the Game Engine which
is to keep the overhead minimal and thus increase the perfomance. Other design
decisions that were made for the development of the engine is the omission of
the C++ standard library and using the Vulkan loader to assign the function
pointers after compiling instead of linking. The first steps for the engine
implementation after the graphics pipeline will be the handling of the memory
allocation and mesh/texture loading. After that we want to implement an
animation system and a very basic interface. As one of the last parts of the
engine we want to implement a physically based rendering system and make use of
some of the perfomance we have saved in the first place.


Notes:
- Vulkan
- Parts of the engine: animation, particle, TheBrendeLoader
- (procedural levels)
- physically based rendering
- make extensive use of different vertex-shaders
- very minimalistic and pure, just like God's own Game Engine
- no c++ standard library
- no bloat allowed
* Big Idea Bullseye
[insert bullseye image]
* Development Schedule

*Layers of Development*:
1. Functional Minimum:
   - One basic level(including start and finish tiles)
   - movement of cube
   - slippery floor type
   - Engine Goals: Graphics pipeline, loading meshes, textures, animation system, interface, particle system, tangent space normals
2. Low Target:
   - floors with grip
   - have sides differently colored
   - finish condition: cube must land on a specific side on the finish tile
   - Load Levels from .txt file
3. Desirable Target:
   - cube can be folded open
   - multiple finish tiles
4. High Target:
   - different worlds
   - implementation of physically based rendering
5. Extras:
   - have players set floors to floor types themselves

*Timeline*: Excel Sheet?

** Task Distributions
For every milestone we schedule the following:
#+attr_latex: :align |c|c|c|
|-----------------------+--------+-------------|
| Task                  | Member | Spent hours |
|-----------------------+--------+-------------|
| Project documentation | All    |           3 |
|-----------------------+--------+-------------|
| Presentation          | All    |           2 |
|-----------------------+--------+-------------|

In general:
#+attr_latex: :align |c|l|c|c|
|---------------+-------------------------------+-----------+---------------|
| Category      | Tasks                         | Member(s) | Planned hours |
|---------------+-------------------------------+-----------+---------------|
| Brainstorming |                               | All       |             3 |
|---------------+-------------------------------+-----------+---------------|
| Engine Work   | Implementation of the         | All       |           200 |
|               | 3D graphics engine for        |           |               |
|               | loading meshes, animations    |           |               |
|               | ...                           |           |               |
|---------------+-------------------------------+-----------+---------------|
| Inputs        | Ensure movement of cube       | Minh      |            20 |
|               | through buttons presses       |           |               |
|---------------+-------------------------------+-----------+---------------|
| Gameplay      | - Cube can be moved           | Minh      |            30 |
|               | - Cube can be folded open     | Felix     |               |
|---------------+-------------------------------+-----------+---------------|
| Win Condition | Cube has to land on finish    | Minh      |            30 |
|               | tile                          | Felix     |               |
|               | + on a specific side          |           |               |
|               | + on multiple finish tiles    |           |               |
|               | at the same time (by folding  |           |               |
|               | open)                         |           |               |
|---------------+-------------------------------+-----------+---------------|
| Level Design  | Designing puzzles,            | Felix     |            40 |
|               | challenges                    | Jonas     |               |
|---------------+-------------------------------+-----------+---------------|
| Physics       | Ensure different movement     | All       |            15 |
|               | behavior on different tiles   |           |               |
|---------------+-------------------------------+-----------+---------------|
| Art           | - Create different animations | Felix     |            60 |
|               | for different events          | Jonas     |               |
|               | - Particle effects            |           |               |
|               | - Original music              |           |               |
|---------------+-------------------------------+-----------+---------------|
| UI            | - Convey basic information    | Jonas     |            10 |
|               | to player                     |           |               |
|               | - Keep it rather simplistic   |           |               |
|---------------+-------------------------------+-----------+---------------|
| Playtesting   | Testing and fixing            | All       |            10 |
|---------------+-------------------------------+-----------+---------------|
| Trailer       |                               | All       |            30 |
|---------------+-------------------------------+-----------+---------------|
| Additional    | - Different world designs     | All       | leftover time |
| Content       | - Players setting floors to   |           |               |
|               | specific type themselves      |           |               |
|               | ...                           |           |               |
|---------------+-------------------------------+-----------+---------------|

* Assessment
# main strength, target audience, world view for design, criteria for success

{{{insert_game_name_here}}} is designed to be a cozy and fun puzzle game for people to enjoy
regardless of prior experiences of puzzle games or even video games in general.
To achieve that, the game will have to be easily accessible not requiring a lot
of prior knowledge. Later levels will add more and more mechanics effectively
raising the difficulty level which hopefully will keep players invested. The
difficulty curve in form of the levels provides one of the biggest challenges in
the development as a sudden difficulty spike can lead to a lot of frustration
while low curve may bore players.

Although we intend to provide players with healthy challenges along the levels,
we generally want {{{insert_game_name_here}}} to be a relaxing game to be played
from time to time.

# Notes:
# - all about simplicity, no bombast
# - easy accessibility
# - just fun & cozy puzzle people can play from time to time
# - we hope for people to calm down when figuring out solutions for trickier levels
