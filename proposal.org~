#+options:  html-postamble:nil toc:nil title:nil
#+macro: insert_game_name_here qubie or quboi
#+macro: insert_team_name_here FünfKopf

#+author: Felix Brendel, Jonas Helms, Van Minh Pham
#+title: Game Idea Proposal: {{{insert_game_name_here}}}

#+latex_header: \usepackage[margin=1in]{geometry}
#+latex_header: \usepackage{titling}
#+latex_header: \renewcommand{\familydefault}{\sfdefault}

#+begin_export latex
\begin{titlepage}
\begin{center}
\vspace*{2 cm}
\huge
\textbf{\thetitle}

\vspace{1cm}
\Large
Team \textit{FünfKopf}:

\vspace{0.2cm}
Felix Brendel \\ Jonas Helms \\ Van Minh Pham

\vspace{2cm}
\large
November 2020

\end{center}
\tableofcontents
\end{titlepage}
\clearpage
#+end_export

* Game Description

We as the team {{{insert_team_name_here}}} believe that great games build on
simple concepts. A perfect example for such a game is [[https://en.wikipedia.org/wiki/Portal_(video_game)][Portal]] (Valve, 2007). The
game magazine GameStar even ranked it number one on the list of the 250 best pc
games of all time, which they published as the special edition issue 01/2020.

** Game design of Portal

Portal builds on the concept of portals that connect two positions in the game
world. When the players enter one portal, they instantly appear at the location
of the other portal. Using this, the game is divided into levels, each with a
specific starting point and target the players have to reach.

Just this basic concept -- teleporting to another position -- alone however, is
not enough to create an interesting game. Starting from the simple concept one
can begin to shape the game mechanics by exploring different ideas. In the case
of Portal they might have looked like this:

 1. What if the players could place the portals thmeselves?
    - Give the players a portal gun and let them shoot the walls to place
      portals on them
 2. What if there are some surfaces, the players cannot place portals on?
    - If players can place portals everywhere, it might be hard to create
      challenging levels, so also use surfaces, where no portalas can be placed
      on
 3. What if some levels require the players to transport objects in the levels
    to solve them?
    - Let players pick up and carry one object at a time. This also harmonizes
      with the the Portal mechanic, as players can carry objects through the
      portal, adding depth to the game design.
 4. What if there are some barriers, that when moved through, destroy the
    carried object?
    - Letting the players carry the objects freely through the level might make
      the levels too easy, so use barriers where the players cannot carry
      objects through; they will have to find another way

It is interesting to note, that idea 2 and 4 seem to be direct responses to the
ideas 1 and 3.

#+attr_latex: :width 0.4\textwidth
#+caption: The layered design of the game portal
[[./images/design_portal.png]]

** Game design of {{{insert_game_name_here}}}

Seeing this we also wanted to design our game in a similar fashion. Our game
concept follows the given theme /wet and slippery/: *The players should slide
around on a slippery floor*[fn:slippery]. This is our main mechanic.


We decided with this mechanic the most fitting game would be a puzzle game where
the player controls a simple object. This is where we had to make some
descisions.

[fn:slippery] Of course the word slippery is a bit vague. We thought about what
    it means to us if something is "sippery" or "wet". We came up with these
    simple definitions: Slippery is an attribut of a surface which implies that
    the surface friction is low and the attribute slippery can only be observed
    when another object is touching and sliding on it. "Wet" on the other hand
    is to us the sensation you feel when you touched a liquid. Usually it is
    connected to a reduced surface friction of wet objects.

***  2D vs 3D

It was clear, that a 3D game would fit better to the setting of this practical
course. However we also really liked the idea of 3D puzzle games

*** What kind of object should the player control?

 - A sphere      :: There are some games that successfully use spheres as the
   players' characters, however it seemed that a sphere would not feel like
   slipping on the ground, it would rather be a rolling motion.
 - A cube        :: Could be a good option
 - A tetrahedron :: Could be a good option

Of course, as with Portal, we need to ask ourselves explorative questions to
experiment with additional mechanics.

*** What if not the whole ground is slippery?

If there are some sections on the ground that are not slippery, we could make
the cube flip on it's side instead. We can make this an additional game
mechanic, where the sides of the cubes are different in some way -- maybe they
are colored differently, or have different shapes on them. Then we could let the
finish tile only activate when the cube reaches it *and* is oriented correctly.

*** What if the object could unfold?

The two objects we considred, cubes and tetrahedrons can unfold, onto a two
dimensional plane. For a cube the unfoldings would lie on a regular square grid,
while the unfoldings of a tetrahedron lie on a regular triangle tiling. For this
game we first consider the cube as a base shape, as it allows for

We wanted to add only one more mechanic to our game -- one more ability that the
player has, that will let us design more deep and interesting puzzles. A sample
unfolding can be seen in Figure [[fig:unfolding_blender]].

#+name: fig:unfolding_blender
#+caption: The unfolding of the cube, following the player's inputs of =up, right, right, up, right=
[[./images/unfolding_blender2.png]]


Note also, that inherently from the fundamental geometric princaples, there is a
limited amout of valid unfoldings. An illustration of all possible unfoldings
can be seen in Figure [[fig:unfoldings_scheme]]. This is the kind of complexity in a
puzzle game we really want to highlight. Everybody can imagine a cube flipping
over and think about which side will be facing upwards or downwards, but using
this complexity -- which is really accessible to everybody -- we can then design
levels that require the player to plan ahead their movement and flips and
unfolds throughout the level.

#+name: fig:unfoldings_scheme
#+caption: All possible
#+attr_latex: :width 0.4\textwidth
[[./images/unfolding_schemes.png]]

*** Bring it all together
TODO(Felix) explain the details one more time

- {{{insert_game_name_here}}} is a tile-based puzzle game
- in each level the player moves a cube from start tile to finish tile
- multiple floor-types:
  - slippery floor:
    - cube cannot change moving direction after button input until obstacle is hit
    - cube does not change the orientation of the cube
  - floors with grip:
    - on one button press cube moves only once
    - cube turns with each movement
- add mechanics every few levels -> steady learning curve:
  - cube is colored differently on every side
  - cube needs to be in a specific orientation on the finish tile
  - cube can be folded open:
    - bridge slippery tiles
    - multiple finish tiles one which all cube sides have to be in the end
  - player has to set tile types themselves
- so far no story or context, just fun puzzling for the sake of fun puzzling
  -> more freedom for ideas, not bound to setting or story
  -> bigger emphasis on simplicity


** Setting of {{{insert_game_name_here}}}

TODO(FELIX): this
** Visual Design of {{{insert_game_name_here}}}
- minimal interface -> need for intuitive controls and gameplay
** Audio Design of {{{insert_game_name_here}}}

** Sample level

TODO(FELIX): this

* Technical Achievement
# detail core technical item (1+)
** Introduction
The central secondary big bullseye idea for our project is to develop our game idea in
our own game engine. Our group always wanted to build their own game engine from
scratch and we thought that this practical provided the perfect opportunity to
put this into reality. The fact that we can use the second mandatory practical
course to further expand on the engine only affirmed this notion as we are then
able to segment the development of the engine over two semesters and can leave
more focus to the development of the game and it's optimization.
**  Motivation
The main motivation to build our own engine stems from the fact that we believe
that we can then provide better optimization and reduce the overhead for our
games on all levels of the engine, from the graphics pipeline to resource
allocation and garbage collection. Furthermore we believe that building a game
engine from the ground up presents a perfect learning opportunity, especially
when trying to find suitable optimizations that fit our design philosophy.

** Game Engine
In the following sections we will provide a small overview of the components of
the game engine that we want to develop for this semesters project and how we
try to optimize these. Furthermore we will go over the features of the game
engine that we will most likely tackle in the follow-up project and how we solve
the interim solutions for this semesters game.

*** Graphics pipeline
The game engine will use the Vulkan Graphics API to implement a rendering
pipeline. Vulkan is a new API developed by the Khronos Group (maintainer of
OpenGL) with a focus on overhead reduction and was released in 2016. Using
Vulkan provides a low-level control over the graphics pipeline when compared to
other Graphics API's and has several advantages that also align with our overall
philosophy in the design of the engine:
- The ability to run on all operating systems and devices
- Explicit control over memory management
- Decreased CPU workload due to reduced driver overhead and batching
- Making use of the driver independent Vulkan Loader to access Vulkan API entry
  points
The Vulkan Loader is responsible for transmitting Vulkan API calls to the
appropriate graphcis driver. This means that we just have to connect to the
Vulkan loader in our engine and do not have to worry about drivers. Furthermore
Vulkan pre-compiles shaders into its own binary format called SPIR-V instead of
compiling the shaders at runtime. This allows the use of a larger number of
different shaders per scene and reduces application load times. We want to
utilise the ability to use a high amount of different shaders and put this
feature into to Extras for the game development(Layer 5) but we will most likely
first employ this in the follow-up project.

*** Overhead reduction in the engine
The game engine is developed in the C++ language that all of our team members
are familiar with due to our TUM Bachelor courses such as Game Engine Design. We
have also taken further steps into the direction of our core concept of overhead
reduction by omitting the C++ standard library.
*** Resource & Scene loading
To increase the performance of the engine we want to make sure that the loading
of resources such as a texture map or a mesh is never done redundantly, which is
likely the case in a puzzle game as key components are similar between different
scenes. In order to implement this we created a hashmap for all loaded files to
cross check whether the pathfile has already been used and then just reuse the
already loaded file. This means that we will only load the diff between two
levels which will reduce load time and creates a smoother game player experience
for the player.
*** Garbage collection
*** Physics System
*** Animation system
*** Particle System
*** Sound System
*** Physically base rendering
One goal of the Hight Target of our project (Layer 4) is to increase the
graphical fidelity of our game by implementating a physically based rendering
system. The term "physically based renderer" is purpously left ambigious as we
want to check out how many components of a physically based renderer we can
implement while still keeping a smooth performance on Van Minh "Sepp" Pham's
crappy ass laptop. Using his laptop as a benchmark goal should provide a highly
competetive milestone aswell as a proof of concept to our current investors that
we at {{{insert_team_name_here}}} have the potential to tackle the solution
of world peace and overall global human solidarity.


* Big Idea Bullseye
#+attr_latex: :width 0.5\textwidth
[[./images/bullseye.png]]
* Development Schedule

** Layers of Development
1. Functional Minimum:
   - One basic level(including start and finish tiles)
   - movement of cube
   - slippery floor type
   - Engine Goals: Graphics pipeline, loading meshes, textures, animation system, interface, particle system, tangent space normals
2. Low Target:
   - floors with grip
   - have sides differently colored
   - finish condition: cube must land on a specific side on the finish tile
   - Load Levels from .txt file
3. Desirable Target:
   - cube can be folded open
   - multiple finish tiles
4. High Target:
   - different worlds
   - implementation of physically based rendering
5. Extras:
   - have players set floors to floor types themselves

** Task Distributions
For every milestone we schedule the following:
#+attr_latex: :align |c|c|c|
|-----------------------+--------+-------------|
| Task                  | Member | Spent hours |
|-----------------------+--------+-------------|
| Project documentation | All    |           3 |
|-----------------------+--------+-------------|
| Presentation          | All    |           2 |
|-----------------------+--------+-------------|

In general:
#+attr_latex: :align |c|l|c|c|
|---------------+----------------------------------+-----------+---------------|
| Components    | Tasks                            | Member(s) | Planned hours |
|---------------+----------------------------------+-----------+---------------|
| Brainstorming |                                  | All       |             3 |
|---------------+----------------------------------+-----------+---------------|
| Engine Work   | Implementation of the            | All       |           200 |
|               | 3D graphics engine for           |           |               |
|               | loading meshes, Animation System |           |               |
|               | ...                              |           |               |
|---------------+----------------------------------+-----------+---------------|
| Inputs        | Ensure movement of cube          | Minh      |            20 |
|               | through buttons presses          |           |               |
|---------------+----------------------------------+-----------+---------------|
| Gameplay      | - Cube can be moved              | Minh      |            23 |
|               | - Cube can be folded open        | Felix     |               |
|---------------+----------------------------------+-----------+---------------|
| Win Condition | Cube has to land on finish       | Minh      |            30 |
|               | tile                             | Felix     |               |
|               | - on a specific side             |           |               |
|               | - on multiple finish tiles       |           |               |
|               | at the same time (by folding     |           |               |
|               | open)                            |           |               |
|---------------+----------------------------------+-----------+---------------|
| Level Design  | Designing puzzles,               | Felix     |            40 |
|               | challenges                       | Jonas     |               |
|---------------+----------------------------------+-----------+---------------|
| Animations    | Ensure different movement        | All       |            20 |
|               | behavior on different tiles      |           |               |
|---------------+----------------------------------+-----------+---------------|
| Art           |                                  | Felix     |            60 |
|               | - Environmnet Meshes&Textures    | Jonas     |               |
|               | - Particle effects               |           |               |
|               | - Original music                 |           |               |
|---------------+----------------------------------+-----------+---------------|
| UI            | - Convey basic information       | Jonas     |            10 |
|               | to player                        |           |               |
|               | - Keep it rather simplistic      |           |               |
|---------------+----------------------------------+-----------+---------------|
| Playtesting   | Testing and fixing               | All       |            10 |
|---------------+----------------------------------+-----------+---------------|
| Trailer       |                                  | All       |            30 |
|---------------+----------------------------------+-----------+---------------|
| Additional    | - Different world designs        | All       | leftover time |
| Content       | - Players setting floors to      |           |               |
|               | specific type themselves         |           |               |
|               | ...                              |           |               |
|---------------+----------------------------------+-----------+---------------|

* Assessment
# main strength, target audience, world view for design, criteria for success

{{{insert_game_name_here}}} is designed to be a cozy and fun puzzle game for people to enjoy
regardless of prior experiences of puzzle games or even video games in general.
To achieve that, the game will have to be easily accessible not requiring a lot
of prior knowledge. Later levels will add more and more mechanics effectively
raising the difficulty level which hopefully will keep players invested. The
difficulty curve in form of the levels provides one of the biggest challenges in
the development as a sudden difficulty spike can lead to a lot of frustration
while low curve may bore players.

Although we intend to provide players with healthy challenges along the levels,
we generally want {{{insert_game_name_here}}} to be a relaxing game to be played
from time to time.

# Notes:
# - all about simplicity, no bombast
# - easy accessibility
# - just fun & cozy puzzle people can play from time to time
# - we hope for people to calm down when figuring out solutions for trickier levels
